<!DOCTYPE html><html><head><meta name="generator" content="Hexo 3.8.0"><meta charset="utf-8"><meta name="X-UA-Compatible" content="IE=edge"><meta name="baidu-site-verification" content="1EB8XoOl0C"><meta name="google-site-verification" content="K7thEgdLm0UfRWJ5MGdF7sCcjClSzAlxFLPv2Oz5CGM"><title> Spring 中的 context · 以梦为码的博客</title><meta name="viewport" content="width=device-width, initial-scale=1"><meta name="description" content="Spring 中的 context - Leexuehan"><meta name="keywords"><meta name="author" content="Leexuehan"><link rel="short icon" href="/images/favicon.ico"><link rel="stylesheet" href="/css/bubuzou.css"><link rel="search" type="application/opensearchdescription+xml" href="https://leexuehan.github.io/atom.xml" title="以梦为码的博客"><script src="//cdn1.lncld.net/static/js/3.0.4/av-min.js"></script>
<script src="//unpkg.com/valine/dist/Valine.min.js"></script></head><body><header><div class="header row"> <a href="/" class="logo-link"><img src="/images/logo.png"></a><ul id="nav_list" class="nav nav-list"><li class="nav-list-item"><a href="/" target="_self" data-hover="博文" class="nav-list-link">博文</a></li><li class="nav-list-item"><a href="/archives/" target="_self" data-hover="归档" class="nav-list-link">归档</a></li><li class="nav-list-item"><a href="/categories/闲聊/" target="_self" data-hover="生活" class="nav-list-link">生活</a></li><li class="nav-list-item"><a href="/categories/技术/" target="_self" data-hover="技术" class="nav-list-link">技术</a></li><li class="nav-list-item"><a href="/about/" target="_self" data-hover="关于" class="nav-list-link">关于</a></li></ul><div class="search"><a id="search_btn" href="#search"></a></div><div id="nav_btn" class="nav-btn"><span></span><span></span><span></span></div></div></header><div class="row scroll-con"><section class="container"><!-- for archive page--><div id="postAr" class="post"><article class="post-block"><h1 class="post-title">Spring 中的 context</h1><div class="post-info">2019-05-02<p class="visit"><i data-identity="2019/05/02/Spring-中的-context/" class="article-timer"></i><span>次访问</span></p></div><div class="post-content"><p>本文主要从源码的角度来分析下 Spring 中负责存储 bean 定义的类和接口定义。</p>
<h2 id="BeanFactory"><a href="#BeanFactory" class="headerlink" title="BeanFactory"></a>BeanFactory</h2><p>首先看下，官方在代码中给出的注释：</p>
<blockquote>
<p>The <strong>root interface for accessing a Spring bean container</strong>.This is the basic client view of a bean container。</p>
</blockquote>
<p>是接触所有Spring bean容器的根接口，这个接口被持有大量bean定义的对象实现。</p>
<p><img src="BeanFactory.png" alt="1557203530675"></p>
<p>从其接口中定义的方法即可看出，其为bean容器的真正含义。</p>
<p>ListableBeanFactory 继承了 BeanFactory，为其提供了枚举所有 beans 的方法：</p>
<p><img src="ListerableFactory.png" alt="1557228601676"></p>
<h2 id="ApplicationContext"><a href="#ApplicationContext" class="headerlink" title="ApplicationContext"></a>ApplicationContext</h2><p>而 ApplicationContext 类通过对该接口的扩展，提供了为application提供配置的扩展接口。</p>
<p>根据官方给出的注释，其总共功能有以下几点：</p>
<ol>
<li>对应用的 component 的工厂方法；</li>
<li>一种通用的加载资源文件的方式；</li>
<li>对注册的监听器发布事件的能力；</li>
<li>解析message，支持国家化的能力。</li>
</ol>
<p>这些能力主要通过继承各种接口获得，其自身接口主要扩展的重要方法主要有一个：</p>
<p><img src="ApplicationContext.png" alt="1557229049849"></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">@Nullable</span><br><span class="line">ApplicationContext getParent();</span><br></pre></td></tr></table></figure>
<p>在 SpringBoot 中，context 有其继承体系：<strong>每个不同的 servlet 都有自己独立的 context，而整个 application 有一个根 context，这个 context 是所有 servlet 所共享的</strong>。</p>
<p>所以此处提供了获得父 context 的能力。</p>
<h2 id="ConfigurableApplicationContext"><a href="#ConfigurableApplicationContext" class="headerlink" title="ConfigurableApplicationContext"></a>ConfigurableApplicationContext</h2><p>全部或者绝大多数 application 的context都会实现或者继承该接口。</p>
<p>扩展了一些配置 context 的方法，但是该接口中的方法<strong>仅仅在应用启动或者关闭时</strong>调用。</p>
<p><img src="ConfigurableApplicationContext.png" alt="1557229635757"></p>
<p>提供了set/get environment的方法；注册监听器的方法；当然还有最重要的 refresh 方法。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * Load or refresh the persistent representation of the configuration,</span><br><span class="line"> * which might an XML file, properties file, or relational database schema.</span><br><span class="line"> * &lt;p&gt;As this is a startup method, it should destroy already created singletons</span><br><span class="line"> * if it fails, to avoid dangling resources. In other words, after invocation</span><br><span class="line"> * of that method, either all or no singletons at all should be instantiated.</span><br><span class="line"> * @throws BeansException if the bean factory could not be initialized</span><br><span class="line"> * @throws IllegalStateException if already initialized and multiple refresh</span><br><span class="line"> * attempts are not supported</span><br><span class="line"> */</span><br><span class="line">void refresh() throws BeansException, IllegalStateException;</span><br></pre></td></tr></table></figure>
<p>从注释中我们可以看到该方法的作用：</p>
<blockquote>
<p>加载或者刷新持久层的配置资源，比如 xml、property 或者数据库文件。</p>
<p>因为该方法在应用启动时调用，所以如果失败，则要销毁掉所有已经创建好的单例对象。</p>
<p>换句话说就是：<strong>一旦该方法被调用，要么创建好所有的单例对象，要么一个单例对象都不会创建</strong>。</p>
</blockquote>
<h3 id="AbstractApplicationContext"><a href="#AbstractApplicationContext" class="headerlink" title="AbstractApplicationContext"></a>AbstractApplicationContext</h3><p>对于 ConfigurableApplicationContext，该抽象类提供了大部分的模板实现方法。</p>
<p>这里重点看下 refresh 方法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line">@Override</span><br><span class="line">public void refresh() throws BeansException, IllegalStateException &#123;</span><br><span class="line">   synchronized (this.startupShutdownMonitor) &#123;</span><br><span class="line">      // Prepare this context for refreshing.</span><br><span class="line">      prepareRefresh();</span><br><span class="line"></span><br><span class="line">      // Tell the subclass to refresh the internal bean factory.</span><br><span class="line">      ConfigurableListableBeanFactory beanFactory = obtainFreshBeanFactory();</span><br><span class="line"></span><br><span class="line">      // Prepare the bean factory for use in this context.</span><br><span class="line">      prepareBeanFactory(beanFactory);</span><br><span class="line"></span><br><span class="line">      try &#123;</span><br><span class="line">         // Allows post-processing of the bean factory in context subclasses.</span><br><span class="line">         postProcessBeanFactory(beanFactory);</span><br><span class="line"></span><br><span class="line">         // Invoke factory processors registered as beans in the context.</span><br><span class="line">         invokeBeanFactoryPostProcessors(beanFactory);</span><br><span class="line"></span><br><span class="line">         // Register bean processors that intercept bean creation.</span><br><span class="line">         registerBeanPostProcessors(beanFactory);</span><br><span class="line"></span><br><span class="line">         // Initialize message source for this context.</span><br><span class="line">         initMessageSource();</span><br><span class="line"></span><br><span class="line">         // Initialize event multicaster for this context.</span><br><span class="line">         initApplicationEventMulticaster();</span><br><span class="line"></span><br><span class="line">         // Initialize other special beans in specific context subclasses.</span><br><span class="line">         onRefresh();</span><br><span class="line"></span><br><span class="line">         // Check for listener beans and register them.</span><br><span class="line">         registerListeners();</span><br><span class="line"></span><br><span class="line">         // Instantiate all remaining (non-lazy-init) singletons.</span><br><span class="line">         finishBeanFactoryInitialization(beanFactory);</span><br><span class="line"></span><br><span class="line">         // Last step: publish corresponding event.</span><br><span class="line">         finishRefresh();</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      catch (BeansException ex) &#123;</span><br><span class="line">         if (logger.isWarnEnabled()) &#123;</span><br><span class="line">            logger.warn(&quot;Exception encountered during context initialization - &quot; +</span><br><span class="line">                  &quot;cancelling refresh attempt: &quot; + ex);</span><br><span class="line">         &#125;</span><br><span class="line"></span><br><span class="line">         // Destroy already created singletons to avoid dangling resources.</span><br><span class="line">         destroyBeans();</span><br><span class="line"></span><br><span class="line">         // Reset &apos;active&apos; flag.</span><br><span class="line">         cancelRefresh(ex);</span><br><span class="line"></span><br><span class="line">         // Propagate exception to caller.</span><br><span class="line">         throw ex;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      finally &#123;</span><br><span class="line">         // Reset common introspection caches in Spring&apos;s core, since we</span><br><span class="line">         // might not ever need metadata for singleton beans anymore...</span><br><span class="line">         resetCommonCaches();</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
<p>该方法比较长，但是注释还是比较详细的，我们可以逐块分解的看：</p>
<p>先看<strong>第5行</strong>（以下提到具体的行数均指的是 refresh 方法中的）中的prepareRefresh：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">protected void prepareRefresh() &#123;</span><br><span class="line">   // 设置一些容器 active flag 标志位</span><br><span class="line">   this.startupDate = System.currentTimeMillis();</span><br><span class="line">   this.closed.set(false);</span><br><span class="line">   this.active.set(true);</span><br><span class="line"></span><br><span class="line">   // 初始化一些 environment 中的占位符属性</span><br><span class="line">   initPropertySources();</span><br><span class="line"></span><br><span class="line">   // 校验一些标记为 required 的必要属性</span><br><span class="line">   getEnvironment().validateRequiredProperties();</span><br><span class="line"></span><br><span class="line">   // 存储“准备刷新”的一些监听器.</span><br><span class="line">   if (this.earlyApplicationListeners == null) &#123;</span><br><span class="line">      this.earlyApplicationListeners = new LinkedHashSet&lt;&gt;(this.applicationListeners);</span><br><span class="line">   &#125;</span><br><span class="line">   else &#123;</span><br><span class="line">      // Reset local application listeners to pre-refresh state.</span><br><span class="line">      this.applicationListeners.clear();</span><br><span class="line">      this.applicationListeners.addAll(this.earlyApplicationListeners);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   // 存储事件</span><br><span class="line">   this.earlyApplicationEvents = new LinkedHashSet&lt;&gt;();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>继续看<strong>第8行</strong>的代码 obtainFreshBeanFactory 发生了什么：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">protected ConfigurableListableBeanFactory obtainFreshBeanFactory() &#123;</span><br><span class="line">   refreshBeanFactory();</span><br><span class="line">   return getBeanFactory();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里使用了模板方法，refreshBeanFactory 的实现留给子类，官方给出的注释是：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * 子类必须实现该方法来执行实际的加载工作。</span><br><span class="line"> */</span><br><span class="line">protected abstract void refreshBeanFactory() throws BeansException, IllegalStateException;</span><br></pre></td></tr></table></figure>
<p>getBeanFactory 方法的实现也留给子类，官方的注释是：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * 子类在这里必须返回它内部的bean factory. </span><br><span class="line"> * 这个bean factory 应该实现高效的查询工作，这样重复调用时才不会造成性能损失.</span><br><span class="line"> * 注意：</span><br><span class="line"> * 子类在返回 bean factory 之前必须检查 context 是否属于 active 状态；如果处于 close 状态，则不能获取该对象。</span><br><span class="line"> */</span><br><span class="line">@Override</span><br><span class="line">public abstract ConfigurableListableBeanFactory getBeanFactory() throws IllegalStateException;</span><br></pre></td></tr></table></figure>
<p><strong>第 11 行</strong>，prepareBeanFactory 方法：</p>
<p>对于一些 context 的特征给出了配置，比如加载器、post-processor等。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line">protected void prepareBeanFactory(ConfigurableListableBeanFactory beanFactory) &#123;</span><br><span class="line">   //设置加载器</span><br><span class="line">   beanFactory.setBeanClassLoader(getClassLoader());</span><br><span class="line">   //设置 Spring EL 解析器</span><br><span class="line">   beanFactory.setBeanExpressionResolver(new StandardBeanExpressionResolver(beanFactory.getBeanClassLoader()));</span><br><span class="line">   //设置用于注册 PropertyEditor 的注册机</span><br><span class="line">   beanFactory.addPropertyEditorRegistrar(new ResourceEditorRegistrar(this, getEnvironment()));</span><br><span class="line"></span><br><span class="line">   // Configure the bean factory with context callbacks.</span><br><span class="line">   // 设置一些用于 bean 后期处理的 processor</span><br><span class="line">   beanFactory.addBeanPostProcessor(new ApplicationContextAwareProcessor(this));</span><br><span class="line">   // 忽略一些依赖接口</span><br><span class="line">   beanFactory.ignoreDependencyInterface(EnvironmentAware.class);</span><br><span class="line">   beanFactory.ignoreDependencyInterface(EmbeddedValueResolverAware.class);</span><br><span class="line">   beanFactory.ignoreDependencyInterface(ResourceLoaderAware.class);</span><br><span class="line">   beanFactory.ignoreDependencyInterface(ApplicationEventPublisherAware.class);</span><br><span class="line">   beanFactory.ignoreDependencyInterface(MessageSourceAware.class);</span><br><span class="line">   beanFactory.ignoreDependencyInterface(ApplicationContextAware.class);</span><br><span class="line"></span><br><span class="line">   // BeanFactory interface not registered as resolvable type in a plain factory.</span><br><span class="line">   // MessageSource registered (and found for autowiring) as a bean.</span><br><span class="line">   // 注册具有相应自动装配值得依赖类型</span><br><span class="line">   beanFactory.registerResolvableDependency(BeanFactory.class, beanFactory);</span><br><span class="line">   beanFactory.registerResolvableDependency(ResourceLoader.class, this);</span><br><span class="line">   beanFactory.registerResolvableDependency(ApplicationEventPublisher.class, this);</span><br><span class="line">   beanFactory.registerResolvableDependency(ApplicationContext.class, this);</span><br><span class="line"></span><br><span class="line">   // 注册该监听器用于检测监听器 bean</span><br><span class="line">   beanFactory.addBeanPostProcessor(new ApplicationListenerDetector(this));</span><br><span class="line"></span><br><span class="line">   // Detect a LoadTimeWeaver and prepare for weaving, if found.</span><br><span class="line">   if (beanFactory.containsBean(LOAD_TIME_WEAVER_BEAN_NAME)) &#123;</span><br><span class="line">      beanFactory.addBeanPostProcessor(new LoadTimeWeaverAwareProcessor(beanFactory));</span><br><span class="line">      // Set a temporary ClassLoader for type matching.</span><br><span class="line">      beanFactory.setTempClassLoader(new ContextTypeMatchClassLoader(beanFactory.getBeanClassLoader()));</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   // 注册默认的 environment beans.</span><br><span class="line">   if (!beanFactory.containsLocalBean(ENVIRONMENT_BEAN_NAME)) &#123;</span><br><span class="line">      beanFactory.registerSingleton(ENVIRONMENT_BEAN_NAME, getEnvironment());</span><br><span class="line">   &#125;</span><br><span class="line">   if (!beanFactory.containsLocalBean(SYSTEM_PROPERTIES_BEAN_NAME)) &#123;</span><br><span class="line">      beanFactory.registerSingleton(SYSTEM_PROPERTIES_BEAN_NAME, getEnvironment().getSystemProperties());</span><br><span class="line">   &#125;</span><br><span class="line">   if (!beanFactory.containsLocalBean(SYSTEM_ENVIRONMENT_BEAN_NAME)) &#123;</span><br><span class="line">      beanFactory.registerSingleton(SYSTEM_ENVIRONMENT_BEAN_NAME, getEnvironment().getSystemEnvironment());</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>第15行</strong> postProcessBeanFactory 方法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">protected void postProcessBeanFactory(ConfigurableListableBeanFactory beanFactory) &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>也是一个模板方法，官方给出的注释是：</p>
<p>context 内部的 bean factory 初始化后，在此处进行一些修改。<strong>此时所有的bean定义都被加载，但是还没有任何一个bean被实例化。</strong></p>
<p><strong>第 18 行</strong>invokeBeanFactoryPostProcessors方法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">protected void invokeBeanFactoryPostProcessors(ConfigurableListableBeanFactory beanFactory) &#123;</span><br><span class="line">   PostProcessorRegistrationDelegate.invokeBeanFactoryPostProcessors(beanFactory, getBeanFactoryPostProcessors());</span><br><span class="line"></span><br><span class="line">   // Detect a LoadTimeWeaver and prepare for weaving, if found in the meantime</span><br><span class="line">   // (e.g. through an @Bean method registered by ConfigurationClassPostProcessor)</span><br><span class="line">   if (beanFactory.getTempClassLoader() == null &amp;&amp; beanFactory.containsBean(LOAD_TIME_WEAVER_BEAN_NAME)) &#123;</span><br><span class="line">      beanFactory.addBeanPostProcessor(new LoadTimeWeaverAwareProcessor(beanFactory));</span><br><span class="line">      beanFactory.setTempClassLoader(new ContextTypeMatchClassLoader(beanFactory.getBeanClassLoader()));</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>此方法的作用在于：实例化所有的bean 之前，实例化并调用一些 context 内部持有的 BeanFactoryPostProcessor。</p>
<p><strong>第21行</strong>registerBeanPostProcessors方法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">protected void registerBeanPostProcessors(ConfigurableListableBeanFactory beanFactory) &#123;</span><br><span class="line">   PostProcessorRegistrationDelegate.registerBeanPostProcessors(beanFactory, this);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>注册所有的 bean 后期处理类。 </p>
<p><strong>第24行</strong> initMessageSource 方法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">protected void initMessageSource() &#123;</span><br><span class="line">   ConfigurableListableBeanFactory beanFactory = getBeanFactory();</span><br><span class="line">   if (beanFactory.containsLocalBean(MESSAGE_SOURCE_BEAN_NAME)) &#123;</span><br><span class="line">      this.messageSource = beanFactory.getBean(MESSAGE_SOURCE_BEAN_NAME, MessageSource.class);</span><br><span class="line">      // Make MessageSource aware of parent MessageSource.</span><br><span class="line">      if (this.parent != null &amp;&amp; this.messageSource instanceof HierarchicalMessageSource) &#123;</span><br><span class="line">         HierarchicalMessageSource hms = (HierarchicalMessageSource) this.messageSource;</span><br><span class="line">         if (hms.getParentMessageSource() == null) &#123;</span><br><span class="line">            // Only set parent context as parent MessageSource if no parent MessageSource</span><br><span class="line">            // registered already.</span><br><span class="line">            hms.setParentMessageSource(getInternalParentMessageSource());</span><br><span class="line">         &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      if (logger.isTraceEnabled()) &#123;</span><br><span class="line">         logger.trace(&quot;Using MessageSource [&quot; + this.messageSource + &quot;]&quot;);</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">   else &#123;</span><br><span class="line">      // Use empty MessageSource to be able to accept getMessage calls.</span><br><span class="line">      DelegatingMessageSource dms = new DelegatingMessageSource();</span><br><span class="line">      dms.setParentMessageSource(getInternalParentMessageSource());</span><br><span class="line">      this.messageSource = dms;</span><br><span class="line">      beanFactory.registerSingleton(MESSAGE_SOURCE_BEAN_NAME, this.messageSource);</span><br><span class="line">      if (logger.isTraceEnabled()) &#123;</span><br><span class="line">         logger.trace(&quot;No &apos;&quot; + MESSAGE_SOURCE_BEAN_NAME + &quot;&apos; bean, using [&quot; + this.messageSource + &quot;]&quot;);</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>该方法进行了两方面的处理：</p>
<p>如果此 context中的 beanFactory 有 MessageSource 属性，则直接获取其值，并将其父MessageSource 设置到此context 的父context中；</p>
<p>如果此 context 中的 beanFactory 没有 MessageSource 属性，则直接使用 parent context中的 MessageSource。</p>
<p><strong>第27行</strong>initApplicationEventMulticaster：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">protected void initApplicationEventMulticaster() &#123;</span><br><span class="line">   ConfigurableListableBeanFactory beanFactory = getBeanFactory();</span><br><span class="line">   if (beanFactory.containsLocalBean(APPLICATION_EVENT_MULTICASTER_BEAN_NAME)) &#123;</span><br><span class="line">      this.applicationEventMulticaster =</span><br><span class="line">            beanFactory.getBean(APPLICATION_EVENT_MULTICASTER_BEAN_NAME, ApplicationEventMulticaster.class);</span><br><span class="line">   //去掉日志打印</span><br><span class="line">   else &#123;</span><br><span class="line">      this.applicationEventMulticaster = new SimpleApplicationEventMulticaster(beanFactory);</span><br><span class="line">      beanFactory.registerSingleton(APPLICATION_EVENT_MULTICASTER_BEAN_NAME, this.applicationEventMulticaster);</span><br><span class="line">      //去掉日志打印</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>此方法初始化 ApplicationEventMulticaster 广播器。</p>
<p>如果本地 context中有该属性，则直接获取值，如果没有则构造一个默认的SimpleApplicationEventMulticaster。</p>
<p>第30行 onRefresh 方法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">protected void onRefresh() throws BeansException &#123;</span><br><span class="line">   // For subclasses: do nothing by default.</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>又是一个模板方法，留待子类去实现。</p>
<p>主要是增加一些特定context 的 refresh 工作，在一些特殊的 bean 初始化时调用，该调用在任何单例对象实例化之前。</p>
<p><strong>第33行</strong>registerListeners，检出并注册所有实现了ApplicationListener的监听器，如果此时有 event，则分发之。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">protected void registerListeners() &#123;</span><br><span class="line">   // Register statically specified listeners first.</span><br><span class="line">   for (ApplicationListener&lt;?&gt; listener : getApplicationListeners()) &#123;</span><br><span class="line">      getApplicationEventMulticaster().addApplicationListener(listener);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   // Do not initialize FactoryBeans here: We need to leave all regular beans</span><br><span class="line">   // uninitialized to let post-processors apply to them!</span><br><span class="line">   String[] listenerBeanNames = getBeanNamesForType(ApplicationListener.class, true, false);</span><br><span class="line">   for (String listenerBeanName : listenerBeanNames) &#123;</span><br><span class="line">      getApplicationEventMulticaster().addApplicationListenerBean(listenerBeanName);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   // Publish early application events now that we finally have a multicaster...</span><br><span class="line">   Set&lt;ApplicationEvent&gt; earlyEventsToProcess = this.earlyApplicationEvents;</span><br><span class="line">   this.earlyApplicationEvents = null;</span><br><span class="line">   if (earlyEventsToProcess != null) &#123;</span><br><span class="line">      for (ApplicationEvent earlyEvent : earlyEventsToProcess) &#123;</span><br><span class="line">         getApplicationEventMulticaster().multicastEvent(earlyEvent);</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>第36行</strong>finishBeanFactoryInitialization方法：</p>
<p>完成此 context 中所有 factory bean 的初始化工作，<strong>实例化剩下的非惰性加载单例对象</strong>。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">protected void finishBeanFactoryInitialization(ConfigurableListableBeanFactory beanFactory) &#123;</span><br><span class="line">   // Initialize conversion service for this context.</span><br><span class="line">   if (beanFactory.containsBean(CONVERSION_SERVICE_BEAN_NAME) &amp;&amp;</span><br><span class="line">         beanFactory.isTypeMatch(CONVERSION_SERVICE_BEAN_NAME, ConversionService.class)) &#123;</span><br><span class="line">      beanFactory.setConversionService(</span><br><span class="line">            beanFactory.getBean(CONVERSION_SERVICE_BEAN_NAME, ConversionService.class));</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   // Register a default embedded value resolver if no bean post-processor</span><br><span class="line">   // (such as a PropertyPlaceholderConfigurer bean) registered any before:</span><br><span class="line">   // at this point, primarily for resolution in annotation attribute values.</span><br><span class="line">   if (!beanFactory.hasEmbeddedValueResolver()) &#123;</span><br><span class="line">      beanFactory.addEmbeddedValueResolver(strVal -&gt; getEnvironment().resolvePlaceholders(strVal));</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   // Initialize LoadTimeWeaverAware beans early to allow for registering their transformers early.</span><br><span class="line">   String[] weaverAwareNames = beanFactory.getBeanNamesForType(LoadTimeWeaverAware.class, false, false);</span><br><span class="line">   for (String weaverAwareName : weaverAwareNames) &#123;</span><br><span class="line">      getBean(weaverAwareName);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   // Stop using the temporary ClassLoader for type matching.</span><br><span class="line">   beanFactory.setTempClassLoader(null);</span><br><span class="line"></span><br><span class="line">   // Allow for caching all bean definition metadata, not expecting further changes.</span><br><span class="line">   beanFactory.freezeConfiguration();</span><br><span class="line"></span><br><span class="line">   // Instantiate all remaining (non-lazy-init) singletons.</span><br><span class="line">   beanFactory.preInstantiateSingletons();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>重点放在下面两行上：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">// Allow for caching all bean definition metadata, not expecting further changes.</span><br><span class="line">beanFactory.freezeConfiguration();</span><br><span class="line"></span><br><span class="line">// Instantiate all remaining (non-lazy-init) singletons.</span><br><span class="line">beanFactory.preInstantiateSingletons();</span><br></pre></td></tr></table></figure>
<p>第一步 freeze 所有的 bean定义数据，该定义不能被更改；</p>
<p>第二步 开始真正实例化所有的单例。</p>
<p><strong>第39行</strong>finishRefresh方法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">protected void finishRefresh() &#123;</span><br><span class="line">   // Clear context-level resource caches (such as ASM metadata from scanning).</span><br><span class="line">   clearResourceCaches();</span><br><span class="line"></span><br><span class="line">   // Initialize lifecycle processor for this context.</span><br><span class="line">   initLifecycleProcessor();</span><br><span class="line"></span><br><span class="line">   // Propagate refresh to lifecycle processor first.</span><br><span class="line">   getLifecycleProcessor().onRefresh();</span><br><span class="line"></span><br><span class="line">   // Publish the final event.</span><br><span class="line">   publishEvent(new ContextRefreshedEvent(this));</span><br><span class="line"></span><br><span class="line">   // Participate in LiveBeansView MBean, if active.</span><br><span class="line">   LiveBeansView.registerApplicationContext(this);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>此时正式宣告完成 context 的refresh 工作，调用 LifecycleProcessor 的 onRefresh 方法，之后发布 ContextRefreshEvent 事件。</p>
<h4 id="GenericApplicationContext"><a href="#GenericApplicationContext" class="headerlink" title="GenericApplicationContext"></a>GenericApplicationContext</h4><p>GenericApplicationContext 继承了 AbstractApplicationContext。</p>
<p>官方给出的注释着重强调了一个功能：</p>
<blockquote>
<p>register a variety of bean definitions.</p>
</blockquote>
<p>意思即注册各种bean定义。这里的各种包括形式上的，可以 xml，也可以是其他类型。</p>
<p>比如下面的官方给出的例子：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">GenericApplicationContext ctx = new GenericApplicationContext();</span><br><span class="line">//可以是 xml 形式的</span><br><span class="line">XmlBeanDefinitionReader xmlReader = new XmlBeanDefinitionReader(ctx);</span><br><span class="line">xmlReader.loadBeanDefinitions(new ClassPathResource(&quot;applicationContext.xml&quot;));</span><br><span class="line">//也可以是 property 形式的</span><br><span class="line">PropertiesBeanDefinitionReader propReader = new PropertiesBeanDefinitionReader(ctx);</span><br><span class="line">propReader.loadBeanDefinitions(new ClassPathResource(&quot;otherBeans.properties&quot;));</span><br><span class="line"></span><br><span class="line">//最终只要调用 refresh 方法进行加载和实例化即可</span><br><span class="line">ctx.refresh();</span><br><span class="line"></span><br><span class="line">//获取我们在资源文件中注册的bean</span><br><span class="line">MyBean myBean = (MyBean) ctx.getBean(&quot;myBean&quot;);</span><br></pre></td></tr></table></figure>
<p>它的注册功能主要通过继承BeanDefinitionRegistry来扩展。关于Spring中的bean，后面专门介绍。</p>
<h5 id="GenericWebApplicationContext"><a href="#GenericWebApplicationContext" class="headerlink" title="GenericWebApplicationContext"></a>GenericWebApplicationContext</h5><p>此类继承 GenericApplicationContext，专门为 web 环境提供上下文。</p>
<h2 id="WebApplicationContext"><a href="#WebApplicationContext" class="headerlink" title="WebApplicationContext"></a>WebApplicationContext</h2><p><img src="WebApplicationContextRelation.png" alt="1557271387505"></p>
<p>从上图可以看到 WebApplicationContext 和 ConfigurableApplicationContext 级别相同，都是 ApplicationContext 的直接子类，其提供的功能不相同。</p>
<p>前面介绍 ConfigurableApplicationContext ，其核心功能就是管理 Spring 中的 beans，包括定义、实例化、启动环境、资源文件加载解析等等，为我们提供了一种管理 context 的接口；</p>
<p>而WebApplicationContext ，顾名思义就是专门为 web application 提供配置的。</p>
<p><img src="WebApplicationContext.png" alt="1557271831768">)</p>
<p>从上图中可以看到，WebApplicationContext 只扩展了一个方法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * Return the standard Servlet API ServletContext for this application.</span><br><span class="line"> */</span><br><span class="line">@Nullable</span><br><span class="line">ServletContext getServletContext();</span><br></pre></td></tr></table></figure>
<p>ServletContext 提供了一组方法用于一个Servlet与其Servlet 容器交流，关于 Servlet 后面会继续探究。</p>
<p>而从其成员变量属性来看，都是跟请求与响应相关。所以这是一个专门为 web application提供的 context。</p>
<p>同上面的 ConfigurableApplicationContext 一样，WebApplicationContext  也具有继承属性。</p>
<p><strong>每一个 application 中只有一个 root context，但是每一个 servlet 都具有自己的 child context。</strong></p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>此文对 Spring 中的几个重要的 context 进行了分析，尤其是对 AbstractApplicationContext 的主要脉络进行了梳理。</p>
</div></article></div><div class="right-container"><div class="widget"><div id="arAnchorBar"></div></div></div></section></div><div class="right-menu"></div><div class="modal search-modal"><div class="input-field"><input type="text" id="search_input"><label for="search-input">搜索</label></div><div id="search_result" class="search-result"></div></div><div class="blog-overlay"></div><footer class="row"><div class="footer-con"><div class="paginator"><a href="/2019/07/06/SpringMVC处理及返回请求探究/" title="SpringMVC处理及返回请求探究" class="prev">上一篇</a><a href="/2018/08/15/Kafka之Producer/" title="Kafka之Producer" class="next">下一篇</a></div><a href="#comment" class="comment-anchor"></a><div id="vcomments"></div><script>new Valine({
    el: "#vcomments",
    appId: "aD8jJBpu4oew3ovNY73z6Rdq-gzGzoHsz",
    appKey: "FdzS5SOPHdhYQoEUngQ8K2QW",
    notify: false,
    verify: false,
    avatar: "robohash",
    visitor: true,
    placeholder: "随便说点什么～.～",
});</script><div class="copyright"><p>© 2016 - 2019 <a target="_blank">Leexuehan</a>, powered by <a href="https://hexo.io/" target="_blank">Hexo</a> <br> and <a href="https://github.com/Bulandent/hexo-theme-bubuzou" target="_blank">hexo-theme-bubuzou</a></p><p> <span style="padding-right: 6px;">闽ICP备16007301号-2</span></p></div><div class="totop"><i></i></div></div></footer><script async src="//cdn.bootcss.com/mathjax/2.6.1/MathJax.js?config=TeX-MML-AM_CHTML"></script><script src="/scripts/jquery-1.8.2.min.js"></script><script src="/scripts/ar-anchor.js"></script><script src="/scripts/main.js"></script><script>(function(b,o,i,l,e,r){b.GoogleAnalyticsObject=l;b[l]||(b[l]=function(){(b[l].q=b[l].q||[]).push(arguments)});b[l].l=+new Date;e=o.createElement(i);r=o.getElementsByTagName(i)[0];e.src='//www.google-analytics.com/analytics.js';r.parentNode.insertBefore(e,r)}(window,document,'script','ga'));ga('create',"UA-65933410-1",'auto');ga('send','pageview');</script><script>const valineAPI = (() => {
try {
    AV.init("aD8jJBpu4oew3ovNY73z6Rdq-gzGzoHsz", "FdzS5SOPHdhYQoEUngQ8K2QW");
} catch(error) {}
const isExist = (identity) => {
    identity = identity || getRealPath();
    let query = new AV.Query('Timer');
    return new Promise((resolve, reject) => {
    query.equalTo("identity", identity);
    query.find().then(results => {
        resolve(results.length > 0);
    }, error => reject(error));
    })
}

const _get = (identity) => {
    let query = null;
    if(identity && identity instanceof Array){
    let querys = [];
    for(let i = 0; i < identity.length; ++i) {
        querys[i] = new AV.Query('Timer');
        querys[i].equalTo('identity', identity[i]);
    }
    query = AV.Query.or.apply(null ,querys);
    } else {
    identity = identity || getRealPath();
    query = new AV.Query("Timer");
    query.equalTo("identity", identity);
    }

    return new Promise((resolve, reject) => {
    query.find()
    .then(results => resolve(results))
    .catch(error => reject(error))
    })
}

const create = (identity) => {
    identity = identity || getRealPath();
    return new Promise((resolve, reject) => {
    let Todo = AV.Object.extend('Timer');
    let todo = new Todo();
    todo.set("times", 1);
    todo.set("identity", identity);
    todo.save().then(res => resolve(true), error => reject(error));
    })
}

const update = (identity) => {
    identity = identity || getRealPath();
    return new Promise((resolve, reject) => {
    let query = new AV.Query('Timer');
    query.equalTo("identity", identity);
    query.find().then(todos => {
        todos.forEach(todo => {
        todo.set("times", todo.attributes.times + 1);
        });
        return AV.Object.saveAll(todos);
    }).then(todos => resolve(true), error => reject(error));
    })
}

return {
    isExist,
    _get,
    update,
    create
}
})()

const calcAndWriteTimes = () => {
let isPost = true;

let timerAllDOM = document.querySelectorAll(".article-timer");

if(isPost) {
    let identity = timerAllDOM[0].getAttribute("data-identity");
    valineAPI.isExist(identity)
    .then(exist => {
    if(exist) {
        return valineAPI.update(identity);
    }
    return new Promise(resolve => resolve(true));
    })
    .then( succuess => valineAPI._get(identity))
    .then( result => timerAllDOM[0].innerText = result[0].attributes.times)
    .catch(error => console.log(error.message))
    return ;
}

let timerDOMCache = {};

for(let timerDOM of timerAllDOM) {
    let identity = timerDOM.getAttribute("data-identity");
    if(timerDOMCache.hasOwnProperty(identity)){
    timerDOMCache[identity].dom.push(timerDOM);
    }else{
    timerDOMCache[identity] = {
        dom: [timerDOM],
        times: undefined
    };
    }
}

let identities = Object.keys(timerDOMCache);
valineAPI._get(identities).then(results => {
    for(let result of results) {
    let {identity, times} = result.attributes;
    timerDOMCache[identity].times = times;
    timerDOMCache[identity].dom.map(item => item.innerText = times);
    }
    for(let identity of identities) {
    if(timerDOMCache[identity].times){
        continue;
    }
    timerDOMCache[identity].dom.map(item => item.innerText = 1);
    valineAPI.create(identity);
    }
}).catch(error => console.log(error.message))
}

if(true){
calcAndWriteTimes();
}</script></body></html>