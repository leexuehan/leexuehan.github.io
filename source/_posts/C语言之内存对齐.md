---
title: C语言之内存对齐
tags:
  - C/C++
  - Linux
date: 2015-08-27 22:24:37
categories: 技术
---


### C语言中各种字节类型的长度

见下表：

![](http://i.imgur.com/9oYfAow.png)

说明：

1.关于char*的长度，其实是可以理解的，因为在16位的编译器中可以寻址的长度为 16bit，故为2字节，同理可以知道在32bit和64bit编译器中的长度分别是4字节和8字节；

2.表格中绿色背景的类型长度都是随着编译器的位数变化而发生变化的。

3.可以看出来，double类型的长度都是 8 字节，long类型只有在64位时才为8字节，float 类型的长度用于与 int型长度一致而short类型的长度是保持不变的。

### 内存对齐的三原则

１:数据成员对齐规则：

结构(struct)(或联合(union))的数据成员，第一个数据成员放在offset为0的地方，以后每个数据成员存储的起始位置要从**该成员大小**的整数倍或者**成员的子成员大小**（只要该成员有子成员，比如说是数组，结构体等）的整数倍开始。

比如int在32位机为４字节,则要从４的整数倍地址开始存储。

 

２:结构体作为成员:如果一个结构里有某些结构体成员,则结构体成员要从**其内部最大元素**大小的整数倍地址开始存储.(struct a里存有struct b,b里有char,int ,double等元素,那b应该从8的整数倍开始存储.)

这里的“其”是指：嵌套的结构体成员。

 

３:收尾工作:结构体的总大小,也就是sizeof的结果,.必须是其内部最大成员的整数倍.不足的要补齐.


### 示例

	typedef struct bb
	{
	 int id;             //[0]....[3]
	 double weight;      //[8].....[15]　　　　　　原则１
	 float height;       //[16]..[19],总长要为８的整数倍,补齐[20]...[23]　　　　　原则３
	}BB;
	
	typedef struct aa
	{
	 char name[2];     //[0],[1]
	 int  id;         //[4]...[7]　　　　　　　　　　原则１
	
	 double score;     //[8]....[15]　　　　
	 short grade;    //[16],[17]　　　　　　　　
	 BB b;             //[24]......[47]　　　　　　　　　　原则２
	}AA;
	
	int main()
	{
	  AA a;
	  cout<<sizeof(a)<<" "<<sizeof(BB)<<endl;
	  return 0;
	}

答案在最后。


### #pragma pack()

实际中用它来指定内存对齐的位数。




答案：48 24