---
title: 设计模式之适配器模式
tags:
  - Design Patterns
date: 2015-09-11 16:13:51
categories: 技术
---

### 概述


> In software engineering, the adapter pattern is a software design pattern that allows the interface of an existing class to be used from another interface.[1] It is often used to make existing classes work with others without modifying their source code.

在软件工程中，适配器模式是一种允许现有的类的接口能被其他接口使用的一种软件模式。它经常被用来使现有的类与其他的类协作，且不用改变他们的源码。

### UML 图

![](http://i.imgur.com/JtNBhx2.png)

从图中可以看出来，适配器模式需要三个元素：Target：用来与Client进行交互，Adaptee是需要适配的类或者接口，Adapter是用来做类型转换的类，是此模式的核心。

### 代码实例

这次没有想出来更好的实际情景，好在这种设计模式也比较好理解。

		package com.ans;
		
		//与客户端交互的类
		class Target {
			public void Request() {
				System.out.println("This is a Request in Target");
			}
		}
		
		//需要适配的类
		class Adaptee {
			public void SpecialRequest() {
				System.out.println("This is a special Request");
			}
		}
		
		//进行转换的类
		class Adapter extends Target{
			private Adaptee adaptee;
			public Adapter(Adaptee adaptee) {
				this.adaptee = adaptee;
			}
			
			@Override 
			public void Request() {
				//System.out.println("This is a Request in Adapter");
				adaptee.SpecialRequest();
			}
		}
		
		public class AdapterPatter {
			public static void main(String[] args) {
				Adaptee adaptee = new Adaptee();
				Target t = new Adapter(adaptee);//适配
				t.Request();
			}
		}
运行结果：

		This is a special Request

当然也可以将 Target 和 Adaptee 设计成为一种接口，然后实现之。

### 总结

刚看到的时候，觉得与装饰器模式，代理模式没啥太大的区别。

经过网上一位大神的指点，感觉清楚了很多。

> **装饰者与适配者模式的区别**
>  
> 1.关于新职责：适配器也可以在转换时增加新的职责，但主要目的不在此。装饰者模式主要是给被装饰者增加新职责的。 
> 
> 2.关于原接口：适配器模式是用新接口来调用原接口，原接口对新系统是不可见或者说不可用的。装饰者模式原封不动的使用原接口，系统对装饰的对象也通过原接口来完成使用。（增加新接口的装饰者模式可以认为是其变种--“半透明”装饰者） 
> 
> 3.关于其包裹的对象：适配器是知道被适配者的详细情况的（就是那个类或那个接口）。装饰者只知道其接口是什么，至于其具体类型（是基类还是其他派生类）只有在运行期间才知道 


> **装饰器模式与代理模式的区别：**
> 
> 代理模式是一种很常用的设计模式，其目的是对其他对象提供一种代理以控制对这个对象的访问。
>  
> 代理模式又分为静态代理和动态代理，静态代理是在程序运行之前就已经存在了代理类，动态代理是程序运行中在内存中生成代理类。 
> 
> 代理模式存在的意义：代理模式是为了解决滥用继承的问题而生的，当想对某个类的功能进行扩充的时候可以使用继承或聚合，很明显用继承的话会造成类泛滥，还有一点就是继承是类具有很强的层级关系的情况下用才好，而紧紧对某个类进行功能的扩充就拿起继承的大刀明显的不合适，那么用聚合呢？ 聚合是一种松耦合的，用聚合创建的代理类就是静态代理，还有更好的代理是动态代理。 
> 
