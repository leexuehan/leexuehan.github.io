---
title: 设计模式之工厂模式
tags:
  - Design Patterns
date: 2015-09-06 15:53:24
categories: 技术
---


### 简单工厂模式(Simple Factory Pattern)

简介


> 简单工厂模式(Simple Factory Pattern)：又称为静态工厂方法(Static Factory Method)模式，它属于类创建型模式。在简单工厂模式中，可以根据自变量的不同返回不同类的实例。


UML图

![](http://i.imgur.com/8PwZoRP.png)



示例


	package com.ans;
		
		//抽象产品类角色
		interface Animal {
			public void Say();
		}
		
		//具体产品角色
		class Dog implements Animal {
			public void Say() {
				System.out.println("I am a Dog");
			}
		}
		
		class Cow implements Animal {
			public void Say() {
				System.out.println("I am a Cow");
			}
		}
		
		
		//工厂类角色
		public class FactoryPattern {
			public static Animal makeAnimal(String name) {
				if(name.equals("Dog"))
					return new Dog();
				else
					return new Cow();
			}
			
			public static void main(String[] args) {
				String s = "Dog";
				String s1 = "Cow";
				makeAnimal(s).Say();
				makeAnimal(s1).Say();
			}
			
		}

**分析**

优点：

1.工厂类含有必要的判断逻辑，可以决定在什么时候创建哪一个产品类的实例，客户端可以免除直接创建产品对象的责任，而仅仅“消费”产品；简单工厂模式通过这种做法实现了对责任的分割，它提供了专门的工厂类用于创建对象。  

2.客户端无需知道所创建的具体产品类的类名，只需要知道具体产品类所对应的**参数**（比如代码中的String 型 name 参数）即可，对于一些复杂的类名，通过简单工厂模式可以减少使用者的记忆量。  

3.通过引入配置文件，可以在不修改任何客户端代码的情况下更换和增加新的具体产品类，在一定程度上提高了系统的灵活性。  

缺点：

1.由于工厂类集中了所有产品创建逻辑，一旦不能正常工作，整个系统都要受到影响。  

2.使用简单工厂模式将会增加系统中类的个数，在一定程序上增加了系统的复杂度和理解难度。  

3.**系统扩展困难，一旦添加新产品就不得不修改工厂逻辑，在产品类型较多时，有可能造成工厂逻辑过于复杂，不利于系统的扩展和维护**。这一点最为突出。比如在上面的例子中，要再增加一个 Monkey 类，一个 Panda 类……，则在工厂类方法中要做很多判断，必然造成代码臃肿。  

4.简单工厂模式由于使用了静态工厂方法，造成工厂角色无法形成基于继承的等级结构。 


### 工厂模式(Factory Pattern)

		package com.ans;
		
		//抽象产品类角色
		interface Animal {
			public void Say();
		}
		
		//具体产品角色

		class Dog implements Animal {
			public void Say() {
				System.out.println("I am a Dog");
			}
		}
		
		class Cow implements Animal {
			public void Say() {
				System.out.println("I am a Cow");
			}
		}
		
		class Panda implements Animal {
			public void Say() {
				System.out.println("I am a Panda");
			}
		}
		
		//一个抽象工厂，只定义了工厂所需要的方法，具体实现由具体工厂来完成
		interface AnimalFactory {
			public Animal makeAnimal();
		}
		
		//造Dog的工厂
		class MakeDog implements AnimalFactory {
			public Animal makeAnimal() {
				return new Dog();
			}
		}
		
		//造Cow的工厂
		class MakeCow implements AnimalFactory {
			public Animal makeAnimal() {
				return new Cow();
			}
		}
		
		//造Panda的工厂
		class MakePanda implements AnimalFactory {
			public Animal makeAnimal() {
				return new Panda();
			}
		}
		
		public class FactoryPattern {
			
			public static void main(String[] args) {
				new MakeDog().makeAnimal().Say();
				new MakeCow().makeAnimal().Say();
				new MakePanda().makeAnimal().Say();
			}
			
		}


**分析**


**在工厂方法模式中，核心的工厂类不再负责所有的产品的创建，而是将具体创建的工作交给子类或者接口的实现类去做。**

这个核心类则摇身一变，成为了一个抽象工厂角色，仅负责给出具体工厂子类必须实现的接口，而不接触哪一个产品类应当被实例化这种细节。 

**优点**

1）在工厂方法模式中，工厂方法用来创建客户所需要的产品，同时还向客户隐藏了哪种具体产品类将被实例化这一细节，用户只需要关心所需产品对应的工厂，无需关心创建细节，甚至无需知道具体产品类的类名。
  
2)基于工厂角色和产品角色的多态性设计是工厂方法模式的关键。它能够使工厂可以自主确定创建何种产品对象，而如何创建这个对象的细节则完全封装在具体工厂内部。工厂方法模式之所以又被称为**多态工厂模式**，正是因为所有的具体工厂类都具有同一抽象父类。  

3)使用工厂方法模式的另一个优点是在系统中加入新产品时，**无需修改抽象工厂和抽象产品提供的接口**，**无需修改客户端**，也无需修改其他的具体工厂和具体产品，而只要添加一个具体工厂和具体产品就可以了，这样，系统的**可扩展性**也就变得非常好，完全符合“开闭原则”。

**缺点**

1)在添加新产品时，需要编写新的具体产品类，而且还要提供与之对应的具体工厂类，**系统中类的个数将成对增加**，在一定程度上增加了系统的复杂度，有更多的类需要编译和运行，会给系统带来一些额外的开销。  

2)由于考虑到系统的可扩展性，**需要引入抽象层**，在客户端代码中均使用抽象层进行定义，增加了系统的抽象性和理解难度，且在实现时可能需要用到DOM、反射等技术，增加了系统的实现难度.


### 抽象工厂模式(Abstract Factory Mode)

抽象工厂模式提供一个创建一系列或相互依赖的对象的接口，而无需指定它们具体的类。

抽象工厂是应对**产品族**概念的。比如说，每个汽车公司可能要同时生产轿车，货车，客车，那么每一个工厂都要有创建轿车，货车和客车的方法。

增加新的产品线很容易，但是无法增加新的产品。

代码实例：

		package com.ans;
		
		//抽象产品类角色
		interface Animal {
			public void Say();
		}
		
		//具体产品角色
		class Dog implements Animal {
			public void Say() {
				System.out.println("I am a Dog");
			}
		}
		
		class Cow implements Animal {
			public void Say() {
				System.out.println("I am a Cow");
			}
		}
		
		class Panda implements Animal {
			public void Say() {
				System.out.println("I am a Panda");
			}
		}
		
		//抽象工厂类角色
		interface AnimalFactory {
			public Animal createDog();
			public Animal createCow();
			public Animal createPanda();
		}
		
		
		//具体工厂类角色
		class Zoo implements AnimalFactory {
			public Animal createDog() {
				return new Dog();
			}
			public Animal createCow() {
				return new Cow();
			}
			
			public Animal createPanda() {
				return new Panda();
			}
		}
		
		
		public class FactoryPattern {
			
			public static void main(String[] args) {
				new Zoo().createCow().Say();
				new Zoo().createDog().Say();
				new Zoo().createPanda().Say();
			}
			
		}


**分析**

代码中的Zoo相当于一个产品线，这个产品线需要生产三种动物：Dog，Cow，Zoo。如果这个产品线需要再生产一种动物，则需要修改原来的接口结构，但是如果再生产一个Zoo，则可以很容易做到，这就是其面向生产线的特点。抽象工厂模式就可以在类内部对产品族的关联关系进行定义和描述，而不必专门引入一个新的类来进行管理。

与工厂模式相比：可以看出来，前者每个产品都需要一个工厂，而后者将其全部封装在一个工厂里面了。

优点：  
（1） 隔离了具体类的生成，使得用户不需要知道什么被创建了。  
（2） 当一个产品族中的多个对象被设计成一起工作时，它能够保证客户端始终只使用同一个产品族中的对象。  
缺点：  
 产品族的扩展将是一件十分费力的事情，假如产品族中需要增加一个新的产品，则几乎所有的工厂类都需要进行修改。所以使用抽象工厂模式时，对产品等级结构的划分是非常重要的。

**总结**

无论是简单工厂模式，工厂方法模式，还是抽象工厂模式，他们都属于工厂模式，在形式和特点上也是极为相似的，他们的最终目的都是为了解耦。在使用时，我们不必去在意这个模式到底工厂方法模式还是抽象工厂模式，因为他们之间的演变常常是令人琢磨不透的。经常你会发现，明明使用的工厂方法模式，当新需求来临，稍加修改，加入了一个新方法后，由于类中的产品构成了不同等级结构中的产品族，它就变成抽象工厂模式了；而对于抽象工厂模式，当减少一个方法使的提供的产品不再构成产品族之后，它就演变成了工厂方法模式。所以，在使用工厂模式时，只需要关心降低耦合度的目的是否达到了。