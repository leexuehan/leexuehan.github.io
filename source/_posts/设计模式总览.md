---
title: 设计模式总览
tags:
  - Design Patterns
date: 2015-09-03 18:37:45
categories: 技术
---

### 前面的话

看过一本书叫《大话设计模式》，但是没有感觉，也没有像网上一位朋友这样分类的。不管，它后面的定义如何，但是这样分类确实给我增加了不少思路。可以稍微捋顺一点了。

### 轮廓

**创建型模式**

1) Factory（工厂）模式：提供的创建对象的接口封装，以及其将类的实例化推迟到子类

2) AbstractFactory（抽象工厂）模式：要创建一组相关或者相互依赖的对象

3) Singleton（单例）模式：创建全局变量/对象

4) Builder（建筑）模式：将创建和表示分开（对象很复杂时）

5) Prototype（原型）模式：自我复制

 

**结构型模式**

1) Bridge（桥接）模式：抽象和实现分别实现

2) Adapter（适配者）模式：提供了将一个类（第三方库）的接口转化为客户（购买使用者）希望的接口。

3) Decorator（装饰者）模式：组合实现类增加的职责

4) Composite（合成）模式：递归构建状结构

5) Flyweight（享元）模式：将对象的状态分为“外部状态”和“内部状态”，将可以被共享（不会变化）的状态作为内部状态存储在对象中，而外部对象我们可以在适当的时候将外部对象最为参数传递给对象。

6) Façade（外观）模式：给用户提供一个高层接口

7) Proxy（代理）模式：逻辑和实现的彻底解耦

 

**行为模式**

1) Template模式

2) Strategy（策略）模式：业务逻辑（算法）具体实现和抽象接口之间解耦

3) State（状态）模式：状态逻辑和动作实现解耦

4) Obsever（观察者）模式：业务逻辑和表示层解耦（1对多的依赖关系）

5) Mementor（备忘录）模式：后悔药——在不破坏封装的前提下，捕获并保存一个类的内部状态，这样就可以利用该保存的状态实施恢复操作

6) Mediator（调停者）模式：对象之间交互和通信

7) Command（命令）模式：Command模式通过将请求封装到一个对象（Command）中，并将请求的接受者存放到具体的ConcreteCommand类中（Receiver）中，从而实现调用操作的对象和操作的具体实现者之间的解耦

8) Visitor（观察者）模式：将更新封装到一个类中

9) Chain of Responsibility （责任链）模式：将可能处理一个请求的对象链接成一个链，并将请求在这个链上传递，直到有对象处理该请求（可能需要提供一个默认处理所有请求的类，例如MFC中的CwinApp类）。

10) Iterator模式：聚合对象的遍历问题

11) Interpreter（翻译）模式：使用一个解释器为用户提供一个一门定义语言的语法表示的解释器，然后通过这个解释器来解释语言中的句子。

之后会尽量把每一种模式都用实例展现出来，以加深印象。

最后向这位网友致敬：http://www.blogbus.com/shijuanfeng-logs/170060138.html