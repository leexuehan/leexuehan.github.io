---
title: 设计模式之建造者模式
tags:
  - Design Patterns
date: 2015-09-03 17:33:35
categories: 技术
---

### 概述

在构造一个对象的时候，往往有很多复杂的过程和次序，例如建造一个机器人，那要先造头，还是要先造身子，这就关乎到一个制造工序的问题。其实建造者模式和工厂模式是很接近的，但是，建造者模式提供了一个更加细粒度的对象的建造过程。

### UML

![](http://i.imgur.com/rN0UxpJ.png)




可以看出建造者模式的结构组成主要有以下四个元素：

1、Builder：给出一个抽象接口，规范建造者对于生产的产品的各个组成部分的建造。这个接口只是定一个规范，不涉及具体的建造，具体的建造让继承于它的子类（ConcreteBuilder）去实现。

2、ConcreteBuilder：实现builder接口，针对不同的商业逻辑，具体化各对象部分的建造，最后返回一个建造好的产品。

3、Director：导演，顾名思义，负责规范流程之用。在指导中不涉及产品的创建，只负责保证复杂对象各部分被创建或按某种顺序创建。

4、Product：复杂对象。

### 代码实现

		package com.ans;
		
		//接口，决定怎么构造或者构造步骤
		interface Builder {
			public void buildPart1();
		
			public void buildPart2();
		
			public void buildPart3();
		
			public Product getProduct();//构造完成之后需要返回
		}
		
		//具体实现
		class ConcretBuilder implements Builder {
			private Product product = null;
		
			public ConcretBuilder(Product product) {
				this.product = product;
			}
		
			public void buildPart1() {
				System.out.println("Building part1....");
				int tmp = product.getVal();
				product.setVal(tmp * 4);
		
			}
		
			public void buildPart2() {
				System.out.println("Building part2");
				int tmp = product.getVal();
				product.setVal(tmp - 2);
			}
		
			public void buildPart3() {
				System.out.println("Building part3");
				int tmp = product.getVal();
				product.setVal(tmp * 3);
			}
		
			public Product getProduct() {
				return this.product;
			}
		}
		
		//需要构造的东西
		class Product {
			public int val = 1;
		
			public int getVal() {
				return val;
			}
		
			public void setVal(int val) {
				this.val = val;
			}
		}


		//还需要一位指挥者
		class Director {
			private Builder builder;
		
			public Director(Builder builder) {
				this.builder = builder;
			}
		
			public void build() {
				System.out.println("Begin to build..");
				builder.buildPart1();
				builder.buildPart2();
				builder.buildPart3();
				System.out.println("Building finished!The result is: "
						+ builder.getProduct().getVal());
			}
		}

		
		//测试例子
		public class TestBuilderPattern {
			public static void main(String[] args) {
				Product product = new Product();
				Builder builder = new ConcretBuilder(product);
				Director director = new Director(builder);
				director.build();
			}
		}

运行结果：

		Begin to build..
		Building part1....
		Building part2
		Building part3
		Building finished!The result is: 6

### 分析

正如代码所示，建造者模式比较简单，总而言之，建造模式是将复杂的内部创建封装在内部，对于外部调用的人来说，只需要传入建造者和建造工具，对于内部是如何建造成成品的，调用者无需关心。

与抽象工厂的区别：在建造者模式里，有个指导者，由指导者来管理建造者，用户是与指导者联系的，指导者联系建造者最后得到产品。即建造模式可以强制实行一种分步骤进行的建造过程。